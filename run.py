#!/usr/bin/env python

"""
Execute the voting schedule for today.

The schedule is stored in the `common.schedule_database_path` sqlite3 database,
which is generated by other scripts beforehand.

Executes the maximum 30 votes that haven't been done yet for each user,
and mark them as done in the schedule database.

This should be run at least once every day.

There is not problem if you run it more than once a day.

This can be run as a cron job. All output is logged to a file.

Consider using anacron for the job:
http://serverfault.com/questions/52335/job-scheduling-using-crontab-what-will-happen-when-computer-is-shutdown-during
which will work as soon as you turn on your computer.

You can interrupt this script with Ctrl + C
and restart it later on without problems.

Only answer uptvoting is currently supported.
"""

import csv
import datetime
import logging
import os.path
import sqlite3
import subprocess

import common

# Don't do any operations to the Stack Overflow server.
# But do change local database. Used for testing.
dry_run_no_server = False

# Some exit statuses indicate that we should not send a notification email.
exit_status_404 = 65
exit_status_no_upvote_arrow = 66
exit_status_human_verification = 67

if len(sys.argv) > 1:
    casperjs_path = sys.argv[0]
else:
    casperjs_path = '/home/ciro/.nvm/v0.10.26/bin/casperjs'

logging.basicConfig(
    filename = os.path.splitext(os.path.realpath(__file__))[0] + '.log',
    level = logging.DEBUG,
    format = '%(asctime)s|%(levelname)s|%(message)s',
)
cookie_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'cookies')
connection = sqlite3.connect(common.schedule_database_path, timeout=0)
connection.row_factory = sqlite3.Row
cursor = connection.cursor()
with open(common.users_csv_path, 'r') as user_file:
    user_csver = csv.reader(user_file)
    for user_row in user_csver:
        logging.debug('user = ' + str(tuple(user_row)))
        user_id, user_email, user_password = user_row
        if user_id != common.user_id_off:
            # TODO if we start running at midnight, we would overestimate the amount of votes used.
            # We could calculate this every time after a vote to increase precision.
            now = datetime.datetime.utcnow()
            today_midnight = datetime.datetime(year=now.year, month=now.month, day=now.day)
            tomorrow_midnight = today_midnight + datetime.timedelta(days=1)
            votes_already_done_today = next(cursor.execute(
                    'SELECT COUNT(*) FROM votes ' +
                    'WHERE user_id = ? AND vote_time >= ? AND vote_time < ?',
                    (user_id, today_midnight, tomorrow_midnight)))[0]
            logging.debug('votes_already_done_today = ' + str(votes_already_done_today))
            cursor.execute(
                    'SELECT * FROM votes ' +
                    'WHERE vote_time IS NULL AND user_id = ? ' +
                    'ORDER BY id ASC LIMIT ?',
                    (user_id, max(common.max_votes_per_day - votes_already_done_today, 0)))
            # Trying to iterate the cursor is problematic because we are going go update rows as well.
            # So we just fetch all to memory and be done with it.
            # Should fit, since we are limited to just a few votes every day.
            vote_rows = cursor.fetchall()
            for vote_row in vote_rows:

                if not dry_run_no_server:
                    # TODO this only logs the row ID, how to log every field?
                    # http://stackoverflow.com/questions/7920284/how-can-printing-an-object-result-in-different-output-than-both-str-and-repr
                    logging.debug('vote = ' + repr(vote_row))
                    args = [
                        casperjs_path,
                        '--ssl-protocol=any',
                        '--proxy=127.0.0.1:9050',
                        '--proxy-type=socks5',
                        common.vote_script_path,
                        user_email,
                        user_password,
                        user_id,
                        str(vote_row['question_id']),
                        str(vote_row['answer_id']),
                        cookie_path
                    ]
                    logging.debug('command = ' + ' '.join(args))
                    process = subprocess.Popen(
                        args,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                    )
                    stdout, stderr = process.communicate()
                    logging.debug('stdout = \n' + stdout)
                    if stderr:
                        logging.error(stderr)
                    exit_status = process.wait()
                else:
                    exit_status = 0

                # TODO deal with different script exit statuses. E.g:
                # - if question deleted or no upvote arrow, schedule more votes for today
                # - if human verification, stop voting with this user, and send an email to admin

                cursor.execute("""UPDATE votes SET vote_time = ?, script_status = ?
                    WHERE user_id = ? AND answer_id = ?""",
                    (datetime.datetime.utcnow(), exit_status, user_id, vote_row['answer_id']))
                if exit_status != 0:
                    logging.error(common.vote_script_path + ' failed with exit status: ' + str(exit_status))
                connection.commit()
        # Switch Tor exit IP.
        process = subprocess.Popen([
            'sudo',
            'killall',
            '-HUP',
            'tor'
        ])
connection.close()
